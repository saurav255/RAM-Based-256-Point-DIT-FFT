/*
 * vdmaTest.c
 *
 *  Created on: Apr 9, 2020
 *      Author: VIPIN
 */
#include "xparameters.h"
#include "xaxivdma.h"
#include "xscugic.h"
#include "sleep.h"
#include <stdlib.h>
#include "xil_cache.h"
#include "xil_cache.h"
/* VPSS includes */
#include "xvprocss.h"
#include "xvidc.h"

#include "xil_io.h"
#include "xil_printf.h"
#include <string.h>

#define HSize 1920
#define VSize 1080
#define FrameSize HSize*VSize*3

static XScuGic Intc;
/* VPSS instance (new) */
//static XVprocSs Vpss;

static int SetupIntrSystem(XAxiVdma *AxiVdmaPtr, u16 ReadIntrId);

//static int SetupVprocSs(void);   /* new helper to init VPSS */

unsigned char Buffer[FrameSize];
// VPROC_SS driver instance
XVprocSs VprocSsInst;

int main(){
	int status;
	  int Status;

    /* --- VPSS setup: initialize and configure color-space conversion --- */
	   Status = SetupVprocSs_1080p(&VprocSsInst);
       if (Status != XST_SUCCESS) {
           xil_printf("VPSS setup failed\r\n");
           return XST_FAILURE;
       }
       xil_printf("VPSS configured OK\r\n");
       /* ------------------------------------------------------------------ */


	int Index;
	u32 Addr;
	XAxiVdma myVDMA;
	XAxiVdma_Config *config = XAxiVdma_LookupConfig(XPAR_AXI_VDMA_0_DEVICE_ID);
	XAxiVdma_DmaSetup ReadCfg;
	status = XAxiVdma_CfgInitialize(&myVDMA, config, config->BaseAddress);
    if(status != XST_SUCCESS){
    	xil_printf("DMA Initialization failed");
    }

    xil_printf("After Vdma init \n");

    ReadCfg.VertSizeInput = VSize;
    ReadCfg.HoriSizeInput = HSize*3;
    ReadCfg.Stride = HSize*3;
    ReadCfg.FrameDelay = 0;
    ReadCfg.EnableCircularBuf = 1;
    ReadCfg.EnableSync = 1;
    ReadCfg.PointNum = 0;
    ReadCfg.EnableFrameCounter = 0;
    ReadCfg.FixedFrameStoreAddr = 0;
    status = XAxiVdma_DmaConfig(&myVDMA, XAXIVDMA_READ, &ReadCfg);
    if (status != XST_SUCCESS) {
    	xil_printf("Write channel config failed %d\r\n", status);
    	return status;
    }

    xil_printf("After Vdma config \n");

    Addr = (u32)&(Buffer[0]);


	for(Index = 0; Index < myVDMA.MaxNumFrames; Index++) {
		ReadCfg.FrameStoreStartAddr[Index] = Addr;
		Addr +=  FrameSize;
	}

	status = XAxiVdma_DmaSetBufferAddr(&myVDMA, XAXIVDMA_READ,ReadCfg.FrameStoreStartAddr);
	if (status != XST_SUCCESS) {
		xil_printf("Read channel set buffer address failed %d\r\n", status);
		return XST_FAILURE;
	}

	XAxiVdma_IntrEnable(&myVDMA, XAXIVDMA_IXR_COMPLETION_MASK, XAXIVDMA_READ);

	SetupIntrSystem(&myVDMA, XPAR_FABRIC_AXI_VDMA_0_MM2S_INTROUT_INTR);
	xil_printf("Bef writing the lines \n");
	//Fill the data
	for(int i=0;i<VSize;i++){
		for(int j=0;j<HSize*3;j=j+3){

			if(j>=0 && j<640*3){
				Buffer[(i*HSize*3)+j] = 0xff;
			    Buffer[(i*HSize*3)+j+1] = 0x00;
			    Buffer[(i*HSize*3)+j+2] = 0x00;
			}
			else if(j>=640*3 && j<1280*3){
				Buffer[(i*HSize*3)+j]   = 0x00;
			    Buffer[(i*HSize*3)+j+1] = 0xff;
			    Buffer[(i*HSize*3)+j+2] = 0x00;
			}
			else {
				Buffer[(i*HSize*3)+j]   = 0x00;
			    Buffer[(i*HSize*3)+j+1] = 0x00;
			    Buffer[(i*HSize*3)+j+2] = 0xff;
			}
		}
	}

	Xil_DCacheFlush();

	status = XAxiVdma_DmaStart(&myVDMA,XAXIVDMA_READ);
	if (status != XST_SUCCESS) {
		if(status == XST_VDMA_MISMATCH_ERROR)
			xil_printf("DMA Mismatch Error\r\n");
		return XST_FAILURE;
	}

    while(1){
    }
}


//int SetupVprocSs(void)
//{
//    int status;
//    XVprocSs_Config *CfgPtr;
//    XVidC_VideoStream inStrm, outStrm;
//
//#ifdef XPAR_V_PROC_SS_0_DEVICE_ID
//    CfgPtr = XVprocSs_LookupConfig(XPAR_V_PROC_SS_0_DEVICE_ID);
//#else
//    xil_printf("ERROR: VPSS device macro not found in xparameters.h\r\n");
//    return XST_FAILURE;
//#endif
//
//    if (!CfgPtr) {
//        xil_printf("ERROR: XVprocSs_LookupConfig returned NULL\r\n");
//        return XST_FAILURE;
//    }
//
//    /* Initialize driver */
//    status = XVprocSs_CfgInitialize(&Vpss, CfgPtr, CfgPtr->BaseAddress);
//    xil_printf("VPSS CfgInitialize returned %d (IsReady=%d)\r\n", status, (int)Vpss.IsReady);
//    if (status != XST_SUCCESS) return status;
//
//    /* Sanity probe (optional) */
//    xil_printf("VPSS base=0x%08x MaxW=%d MaxH=%d Topology=%d PixPerClock=%d\r\n",
//               (unsigned)CfgPtr->BaseAddress, CfgPtr->MaxWidth, CfgPtr->MaxHeight,
//               CfgPtr->Topology, CfgPtr->PixPerClock);
//
//    /* --- Minimal input stream descriptor: RGB, 8bpc --- */
//    memset(&inStrm, 0, sizeof(inStrm));
//    inStrm.ColorFormatId = XVIDC_CSF_RGB;   /* RGB input */
//    inStrm.ColorDepth   = 8;                /* 8 bits per component */
//    /* If you want, also set explicit stream timing fields here (but not required for CSC-only) */
//
//    /* --- Minimal output stream descriptor: YCbCr 4:4:4, 8bpc --- */
//    memset(&outStrm, 0, sizeof(outStrm));
//    outStrm.ColorFormatId = XVIDC_CSF_YCRCB_444; /* YCbCr 4:4:4 output */
//    outStrm.ColorDepth    = 8;
//
//    /* Give the driver the stream info */
//    status = XVprocSs_SetVidStreamIn(&Vpss, &inStrm);
//    xil_printf("SetVidStreamIn returned %d\r\n", status);
//    if (status != XST_SUCCESS) return status;
//
//    status = XVprocSs_SetVidStreamOut(&Vpss, &outStrm);
//    xil_printf("SetVidStreamOut returned %d\r\n", status);
//    if (status != XST_SUCCESS) return status;
//
//    /* Apply config to program sub-cores (CSC) */
//    status = XVprocSs_SetSubsystemConfig(&Vpss);
//    xil_printf("SetSubsystemConfig returned %d\r\n", status);
//    if (status != XST_SUCCESS) {
//        XVprocSs_ReportSubsystemConfig(&Vpss);
//        XVprocSs_ReportSubcoreStatus(&Vpss, XVPROCSS_SUBCORE_CSC);
//        return status;
//    }
//
//    /* Optional: print the resulting config for debug */
//    XVprocSs_ReportSubsystemConfig(&Vpss);
//    XVprocSs_ReportSubcoreStatus(&Vpss, XVPROCSS_SUBCORE_CSC);
//
//    /* Start processing */
//    XVprocSs_Start(&Vpss);
//    xil_printf("VPSS started (CSC-only): RGB -> YCbCr 4:4:4\r\n");
//
//    return XST_SUCCESS;
//}
int vprocss_configure_csc(u32 dev_id, XVidC_ColorFormat in_fmt,
                          XVidC_ColorFormat out_fmt, u16 bits_per_component)
{
    int status;
    XVprocSs_Config *CfgPtr;
    XVprocSs Vpss_local;
    XVidC_VideoStream inStrm, outStrm;

    /* 1) Lookup config */
    CfgPtr = XVprocSs_LookupConfig(dev_id);
    if (!CfgPtr) {
        xil_printf("vprocss: LookupConfig FAILED for dev %u\r\n", (unsigned)dev_id);
        return XST_FAILURE;
    }

    /* 2) Initialize driver instance */
    status = XVprocSs_CfgInitialize(&Vpss_local, CfgPtr, CfgPtr->BaseAddress);
    if (status != XST_SUCCESS) {
        xil_printf("vprocss: CfgInitialize failed (%d)\r\n", status);
        return status;
    }

    /* Optional debug: probe base */
    xil_printf("vprocss: base=0x%08x MaxW=%d MaxH=%d Topology=%d PixPerClock=%d\r\n",
               (unsigned)CfgPtr->BaseAddress, CfgPtr->MaxWidth, CfgPtr->MaxHeight,
               CfgPtr->Toplogy, CfgPtr->PixPerClock);

    /* 3) Minimal stream descriptors (no resolution helpers) */
    memset(&inStrm,  0, sizeof(inStrm));
    memset(&outStrm, 0, sizeof(outStrm));

    /* set formats and depth directly to avoid macro collisions / missing tables */
    inStrm.ColorFormatId = in_fmt;
    inStrm.ColorDepth    = bits_per_component;

    outStrm.ColorFormatId = out_fmt;
    outStrm.ColorDepth    = bits_per_component;

    /* 4) Give the driver the stream info */
    status = XVprocSs_SetVidStreamIn(&Vpss_local, &inStrm);
    if (status != XST_SUCCESS) {
        xil_printf("vprocss: SetVidStreamIn failed %d\r\n", status);
        return status;
    }
    status = XVprocSs_SetVidStreamOut(&Vpss_local, &outStrm);
    if (status != XST_SUCCESS) {
        xil_printf("vprocss: SetVidStreamOut failed %d\r\n", status);
        return status;
    }

    /* 5) Apply config to program sub-cores (CSC) */
    status = XVprocSs_SetSubsystemConfig(&Vpss_local);
    if (status != XST_SUCCESS) {
        xil_printf("vprocss: SetSubsystemConfig failed %d\r\n", status);
        XVprocSs_ReportSubsystemConfig(&Vpss_local);
        XVprocSs_ReportSubcoreStatus(&Vpss_local, XVPROCSS_SUBCORE_CSC);
        return status;
    }

    /* Optional: show configured subcore state */
    XVprocSs_ReportSubsystemConfig(&Vpss_local);
    XVprocSs_ReportSubcoreStatus(&Vpss_local, XVPROCSS_SUBCORE_CSC);

    /* 6) Start */
    XVprocSs_Start(&Vpss_local);
    xil_printf("vprocss: Started CSC: in=%d out=%d bpc=%d\r\n",
               (int)in_fmt, (int)out_fmt, (int)bits_per_component);

    /* If you want the XVprocSs instance available in your code (to call APIs later),
       you can copy Vpss_local into a global XVprocSs var or return a pointer.
       This helper intentionally uses a local XVprocSs so it's drop-in; if you need
       later control, make Vpss_local global and remove the local variable. */

    return XST_SUCCESS;
}
/*****************************************************************************/
 /* Call back function for read channel
******************************************************************************/

static void ReadCallBack(void *CallbackRef, u32 Mask)
{
	static int i=0;
	/* User can add his code in this call back function */
	xil_printf("Read Call back function is called\r\n");
	if(i==0){
		memset(Buffer,0x00,FrameSize);
		i=1;
	}
	else{
		memset(Buffer,0xff,FrameSize);
		i=0;
	}
	Xil_DCacheFlush();
	sleep(1);
}

/*****************************************************************************/
/*
 * The user can put his code that should get executed when this
 * call back happens.
 *
*
******************************************************************************/
static void ReadErrorCallBack(void *CallbackRef, u32 Mask)
{
	/* User can add his code in this call back function */
	xil_printf("Read Call back Error function is called\r\n");

}


static int SetupIntrSystem(XAxiVdma *AxiVdmaPtr, u16 ReadIntrId)
{
	int Status;
	XScuGic *IntcInstancePtr =&Intc;

	/* Initialize the interrupt controller and connect the ISRs */
	XScuGic_Config *IntcConfig;
	IntcConfig = XScuGic_LookupConfig(XPAR_PS7_SCUGIC_0_DEVICE_ID);
	Status =  XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig, IntcConfig->CpuBaseAddress);
	if(Status != XST_SUCCESS){
		xil_printf("Interrupt controller initialization failed..");
		return -1;
	}

	Status = XScuGic_Connect(IntcInstancePtr,ReadIntrId,(Xil_InterruptHandler)XAxiVdma_ReadIntrHandler,(void *)AxiVdmaPtr);
	if (Status != XST_SUCCESS) {
		xil_printf("Failed read channel connect intc %d\r\n", Status);
		return XST_FAILURE;
	}

	XScuGic_Enable(IntcInstancePtr,ReadIntrId);

	Xil_ExceptionInit();
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,(Xil_ExceptionHandler)XScuGic_InterruptHandler,(void *)IntcInstancePtr);
	Xil_ExceptionEnable();

	/* Register call-back functions
	 */
	XAxiVdma_SetCallBack(AxiVdmaPtr, XAXIVDMA_HANDLER_GENERAL, ReadCallBack, (void *)AxiVdmaPtr, XAXIVDMA_READ);

	XAxiVdma_SetCallBack(AxiVdmaPtr, XAXIVDMA_HANDLER_ERROR, ReadErrorCallBack, (void *)AxiVdmaPtr, XAXIVDMA_READ);

	return XST_SUCCESS;
}
