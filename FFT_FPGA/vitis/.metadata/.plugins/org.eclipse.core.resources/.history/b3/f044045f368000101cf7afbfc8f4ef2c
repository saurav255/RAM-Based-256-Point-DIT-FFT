/*
 * vdma_hdmi_vpss_csc.c
 *
 * This code is for displaying a static color bar pattern on an HDMI monitor.
 * It is intended for a Vivado design that uses an AXI VDMA to read from DDR
 * and a Video Processing Subsystem (VPSS) configured for Color Space
 * Conversion ONLY (RGB to YCbCr 4:4:4).
 *
 * - VPSS is configured in software to match the hardware (CSC only).
 * - HDMI configuration is done using standard XIic drivers.
 * - A simple Red, Green, Blue stripe pattern is generated in the frame buffer.
 */

#include "xparameters.h"
#include "xaxivdma.h"
#include "xscugic.h"
#include "xiic.h"
#include "xv_vpss.h" // VPSS driver header
#include "xil_printf.h"
#include "xil_cache.h"
#include "sleep.h"

/************************** Constant Definitions *****************************/

// --- Device IDs from xparameters.h ---
#define VDMA_ID           XPAR_AXI_VDMA_0_DEVICE_ID
#define INTC_ID           XPAR_PS7_SCUGIC_0_DEVICE_ID
#define VDMA_MM2S_INTR_ID XPAR_FABRIC_AXI_VDMA_0_MM2S_INTROUT_INTR
#define IIC_ID            XPAR_AXI_IIC_0_DEVICE_ID
#define VPSS_ID           XPAR_XV_VPSS_0_DEVICE_ID // *** VERIFY THIS ID ***

// --- IIC HDMI Chip Address ---
#define IIC_ADV7511_ADDR  0x39

// --- Video Resolution ---
#define H_ACTIVE          1920
#define V_ACTIVE          1080

// --- Frame Buffer Configuration ---
// Using RGB888 format (3 bytes per pixel).
#define FRAME_STRIDE      (H_ACTIVE * 3)
#define FRAME_SIZE        (FRAME_STRIDE * V_ACTIVE)

/************************** Global Variables *********************************/

// Driver Instances
static XAxiVdma Vdma;
static XScuGic  Intc;
static XIic     Iic;
static XV_Vpss  Vpss; // VPSS driver instance

// Frame buffer in DDR memory, aligned for DMA
unsigned char FrameBuffer[FRAME_SIZE] __attribute__ ((aligned (64)));

/************************** Function Prototypes ******************************/

// Interrupt System Setup
static int SetupIntrController(XScuGic *IntcInstancePtr);
static int SetupVideoIntrSystem(XAxiVdma *AxiVdmaPtr, u16 ReadIntrId, XScuGic *Intc);

// IP Core Setup
static int SetupVdma(u16 DeviceId);
static int SetupVpss(u16 DeviceId);
static int SetupHdmi(u16 IicDeviceId);
static void ConfigureHdmi(void);

// Frame Buffer Generation
void FillFrameBuffer(void);

// VDMA Interrupt Callbacks
static void ReadCallBack(void *CallbackRef, u32 Mask);
static void ReadErrorCallBack(void *CallbackRef, u32 Mask);

/*****************************************************************************/
/**
*
* Main function
*
******************************************************************************/
int main() {
    int Status;

    xil_printf("--- ZedBoard HDMI Display Test (VDMA + VPSS CSC) ---\r\n");

    // 1. Initialize the Interrupt Controller
    Status = SetupIntrController(&Intc);
    if (Status != XST_SUCCESS) {
        xil_printf("Interrupt Controller Initialization failed! Error: %d\r\n", Status);
        return XST_FAILURE;
    }
    xil_printf("Interrupt Controller Initialized Successfully\r\n");

    // 2. Initialize the HDMI Output (configures the ADV7511 chip via IIC)
    Status = SetupHdmi(IIC_ID);
    if (Status != XST_SUCCESS) {
        xil_printf("HDMI Initialization failed! Error: %d\r\n", Status);
        return XST_FAILURE;
    }
    xil_printf("HDMI Initialized Successfully\r\n");

    // 3. Initialize and configure the Video Processing Subsystem (VPSS)
    Status = SetupVpss(VPSS_ID);
    if (Status != XST_SUCCESS) {
        xil_printf("VPSS Initialization failed! Error: %d\r\n", Status);
        return XST_FAILURE;
    }
    xil_printf("VPSS Initialized Successfully for CSC\r\n");

    // 4. Fill the frame buffer with the color bar test pattern
    FillFrameBuffer();
    xil_printf("Frame Buffer filled with test pattern\r\n");

    // 5. Initialize the VDMA
    Status = SetupVdma(VDMA_ID);
    if (Status != XST_SUCCESS) {
        xil_printf("VDMA Initialization failed! Error: %d\r\n", Status);
        return XST_FAILURE;
    }
    xil_printf("VDMA Initialized Successfully\r\n");

    // 6. Setup VDMA interrupts
    Status = SetupVideoIntrSystem(&Vdma, VDMA_MM2S_INTR_ID, &Intc);
    if (Status != XST_SUCCESS) {
        xil_printf("VDMA Interrupt system setup failed! Error: %d\r\n", Status);
        return XST_FAILURE;
    }
    xil_printf("VDMA Interrupt System Setup Successfully\r\n");

    // 7. Start the VDMA transfer to the video pipeline
    Status = XAxiVdma_DmaStart(&Vdma, XAXIVDMA_READ);
    if (Status != XST_SUCCESS) {
        xil_printf("VDMA start failed! Error: %d\r\n", Status);
        return XST_FAILURE;
    }
    xil_printf("VDMA Started. Video output should be visible on HDMI monitor.\r\n");

    // Loop forever as the hardware handles the video stream
    while (1) {
    }

    return XST_SUCCESS;
}

/*****************************************************************************/
/**
* This function initializes and configures the Video Processing Subsystem (VPSS).
* It is configured for Color Space Conversion only.
******************************************************************************/
static int SetupVpss(u16 DeviceId)
{
    int Status;
    XV_Vpss_Config *VpssConfig;
    XVidC_VideoStream InStream, OutStream;

    // Look up the VPSS configuration
    VpssConfig = XV_Vpss_LookupConfig(DeviceId);
    if (VpssConfig == NULL) {
        xil_printf("VPSS device not found for ID %d\r\n", DeviceId);
        return XST_FAILURE;
    }

    // Initialize the VPSS driver
    Status = XV_Vpss_CfgInitialize(&Vpss, VpssConfig, VpssConfig->BaseAddress);
    if (Status != XST_SUCCESS) {
        xil_printf("VPSS CfgInitialize failed: %d\r\n", Status);
        return Status;
    }

    // IMPORTANT: Clear the subsystem configuration. This tells the driver to
    // read the hardware configuration from the IP itself, so it knows that
    // only the CSC core is present.
    XV_Vpss_SetSubsystemConfig(&Vpss);

    // --- Configure Input Stream ---
    InStream.VmId           = XVIDC_VM_1920x1080_60_P;
    InStream.Timing.HActive = H_ACTIVE;
    InStream.Timing.VActive = V_ACTIVE;
    InStream.ColorFormatId  = XVIDC_CSF_RGB;
    InStream.ColorDepth     = VpssConfig->MaxDataWidth;
    InStream.PixPerClk      = VpssConfig->PixPerClock;
    InStream.IsInterlaced   = 0;

    // --- Configure Output Stream ---
    OutStream.VmId           = XVIDC_VM_1920x1080_60_P;
    OutStream.Timing.HActive = H_ACTIVE;
    OutStream.Timing.VActive = V_ACTIVE;
    OutStream.ColorFormatId  = XVIDC_CSF_YCRCB_444; // Target color space
    OutStream.ColorDepth     = VpssConfig->MaxDataWidth;
    OutStream.PixPerClk      = VpssConfig->PixPerClock;
    OutStream.IsInterlaced   = 0;

    // Set the stream formats
    XV_Vpss_SetVideoStream(&Vpss, &InStream, &OutStream);

    // Start the VPSS
    XV_Vpss_Start(&Vpss);

    return XST_SUCCESS;
}


/*****************************************************************************/
/**
* This function fills the frame buffer with a 3-bar color pattern.
* The screen is divided into three vertical bars: Red, Green, and Blue.
******************************************************************************/
void FillFrameBuffer(void) {
    u32 v, h;
    u8 *FramePtr = FrameBuffer;

    for (v = 0; v < V_ACTIVE; v++) {
        for (h = 0; h < H_ACTIVE; h++) {
            if (h < H_ACTIVE / 3) {
                // Red bar
                FramePtr[0] = 0xFF; // R
                FramePtr[1] = 0x00; // G
                FramePtr[2] = 0x00; // B
            } else if (h < (H_ACTIVE * 2) / 3) {
                // Green bar
                FramePtr[0] = 0x00; // R
                FramePtr[1] = 0xFF; // G
                FramePtr[2] = 0x00; // B
            } else {
                // Blue bar
                FramePtr[0] = 0x00; // R
                FramePtr[1] = 0x00; // G
                FramePtr[2] = 0xFF; // B
            }
            FramePtr += 3;
        }
    }
    // IMPORTANT: Flush the data cache after writing to the frame buffer.
    Xil_DCacheFlushRange((UINTPTR)FrameBuffer, FRAME_SIZE);
}

/*****************************************************************************/
/**
* This function sets up the VDMA read channel (Memory-Mapped to Stream).
******************************************************************************/
static int SetupVdma(u16 DeviceId) {
    XAxiVdma_Config *Config;
    XAxiVdma_DmaSetup ReadCfg;
    int Status;
    u32 Addr;

    Config = XAxiVdma_LookupConfig(DeviceId);
    if (!Config) {
        xil_printf("No VDMA found for ID %d\r\n", DeviceId);
        return XST_FAILURE;
    }

    Status = XAxiVdma_CfgInitialize(&Vdma, Config, Config->BaseAddress);
    if (Status != XST_SUCCESS) {
        xil_printf("VDMA CfgInitialize failed: %d\r\n", Status);
        return Status;
    }

    // --- Configure the Read Channel (MM2S) ---
    ReadCfg.VertSizeInput      = V_ACTIVE;
    ReadCfg.HoriSizeInput      = FRAME_STRIDE;
    ReadCfg.Stride             = FRAME_STRIDE;
    ReadCfg.FrameDelay         = 0;
    ReadCfg.EnableCircularBuf  = 1; // Use circular buffer mode
    ReadCfg.EnableSync         = 1; // Gen-Lock to AXI-Stream slave
    ReadCfg.PointNum           = 0;
    ReadCfg.EnableFrameCounter = 0;
    ReadCfg.FixedFrameStoreAddr= 0;

    Status = XAxiVdma_DmaConfig(&Vdma, XAXIVDMA_READ, &ReadCfg);
    if (Status != XST_SUCCESS) {
        xil_printf("VDMA DmaConfig failed: %d\r\n", Status);
        return Status;
    }

    // --- Set the Frame Buffer Address ---
    Addr = (u32)FrameBuffer;
    Status = XAxiVdma_DmaSetBufferAddr(&Vdma, XAXIVDMA_READ, &Addr);
    if (Status != XST_SUCCESS) {
        xil_printf("VDMA DmaSetBufferAddr failed: %d\r\n", Status);
        return Status;
    }

    return XST_SUCCESS;
}


/*****************************************************************************/
/**
* This function initializes the HDMI output path by configuring the ADV7511
* chip via the AXI IIC controller.
******************************************************************************/
static int SetupHdmi(u16 IicDeviceId) {
    XIic_Config *Config;
    int Status;

    // Initialize IIC Driver
    Config = XIic_LookupConfig(IicDeviceId);
    if (Config == NULL) {
        xil_printf("IIC device not found for ID %d\r\n", IicDeviceId);
        return XST_FAILURE;
    }

    Status = XIic_CfgInitialize(&Iic, Config, Config->BaseAddress);
    if (Status != XST_SUCCESS) {
        xil_printf("IIC CfgInitialize failed: %d\r\n", Status);
        return XST_FAILURE;
    }

    // Configure the ADV7511 HDMI Chip
    ConfigureHdmi();

    return XST_SUCCESS;
}

/*****************************************************************************/
/**
* This function sends the configuration sequence to the ADV7511 HDMI
* transmitter chip over I2C to set it up for 1080p output.
******************************************************************************/
void ConfigureHdmi(void) {
    u8 Buffer[2];

    // Set the IIC slave address for the ADV7511
    XIic_SetAddress(&Iic, XII_ADDR_TO_SEND_TYPE, IIC_ADV7511_ADDR);

    // --- ADV7511 Configuration Sequence for 1080p ---
    Buffer[0] = 0x41; Buffer[1] = 0x10; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0x98; Buffer[1] = 0x03; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0x9A; Buffer[1] = 0xE0; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0x9C; Buffer[1] = 0x30; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0x9D; Buffer[1] = 0x61; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0xA2; Buffer[1] = 0xA4; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0xA3; Buffer[1] = 0xA4; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0xAF; Buffer[1] = 0x06; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0xBA; Buffer[1] = 0x60; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0xDE; Buffer[1] = 0x9C; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0xE0; Buffer[1] = 0xD0; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0xF9; Buffer[1] = 0x00; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0x15; Buffer[1] = 0x00; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0x16; Buffer[1] = 0x38; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0x18; Buffer[1] = 0x46; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0x48; Buffer[1] = 0x08; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
    Buffer[0] = 0x41; Buffer[1] = 0x00; XIic_Send(Iic.BaseAddress, IIC_ADV7511_ADDR, Buffer, 2, XIIC_STOP);
}

/*****************************************************************************/
/**
* This function is the callback for the VDMA's MM2S (Read) channel.
******************************************************************************/
static void ReadCallBack(void *CallbackRef, u32 Mask) {
    // Not used in this simple example
}

/*****************************************************************************/
/**
* This is the error callback for the VDMA's MM2S (Read) channel.
******************************************************************************/
static void ReadErrorCallBack(void *CallbackRef, u32 Mask) {
    xil_printf("!!! VDMA Read Error: Mask = 0x%08X\r\n", Mask);
}

/*****************************************************************************/
/**
* This function initializes the SCUGIC interrupt controller.
******************************************************************************/
static int SetupIntrController(XScuGic *IntcInstancePtr) {
    int Status;
    XScuGic_Config *IntcConfig;

    IntcConfig = XScuGic_LookupConfig(INTC_ID);
    if (NULL == IntcConfig) {
        return XST_FAILURE;
    }

    Status = XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig, IntcConfig->CpuBaseAddress);
    if (Status != XST_SUCCESS) {
        return XST_FAILURE;
    }

    // --- Set up exception handling ---
    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                                 (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                                 (void *)IntcInstancePtr);
    Xil_ExceptionEnable();

    return XST_SUCCESS;
}

/*****************************************************************************/
/**
* This function sets up the interrupt system for the VDMA.
******************************************************************************/
static int SetupVideoIntrSystem(XAxiVdma *AxiVdmaPtr, u16 ReadIntrId, XScuGic *Intc) {
    int Status;

    // Connect the VDMA interrupt handler
    Status = XScuGic_Connect(Intc, ReadIntrId,
                             (Xil_InterruptHandler)XAxiVdma_ReadIntrHandler,
                             (void *)AxiVdmaPtr);
    if (Status != XST_SUCCESS) {
        xil_printf("Failed to connect VDMA read interrupt: %d\r\n", Status);
        return XST_FAILURE;
    }

    // Enable the VDMA interrupt
    XScuGic_Enable(Intc, ReadIntrId);

    // --- Register the callback functions ---
    XAxiVdma_SetCallBack(AxiVdmaPtr, XAXIVDMA_HANDLER_GENERAL, ReadCallBack,
                         (void *)AxiVdmaPtr, XAXIVDMA_READ);
    XAxiVdma_SetCallBack(AxiVdmaPtr, XAXIVDMA_HANDLER_ERROR, ReadErrorCallBack,
                         (void *)AxiVdmaPtr, XAXIVDMA_READ);

    // Enable all interrupts on the VDMA read channel
    XAxiVdma_IntrEnable(AxiVdmaPtr, XAXIVDMA_IXR_ALL_MASK, XAXIVDMA_READ);

    return XST_SUCCESS;
}
